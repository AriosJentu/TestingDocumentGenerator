from Scripts import Functions
from Scripts import Globals

from Scripts.Generators import Tests
from Scripts.Generators import Entries
from Scripts.Generators import Documents

CurrentConfiguration = Globals.CurrentConfiguration.get_configuration()

class Assignment:
	'''
	Assignment - parent class to work with assignments, containing 
		all information about them. 
	Must contain default values for next parameters:
	- 'layout' - 'DocumentLayout' with information about 
		document path and replacement string, and it's PageStyle
	- 'test' - 'Test' with it's 'Exercises', 
	- 'entries' - 'Entries' with their 'generate_information' method. 
		This value can't be default, because it's generating by user's asking.
		For this situation exist method 'set_entries'
	- 'document_entries' - 'DocumentEntries' with additional information, 
		which presented in pagestyle exercises format string. 
		This argument may not be presented in class, 
		by default it's empty entry
	- 'prefix' - String with prefix of the assignment. 
		Must contain only latin symbols, and represent logic 
		of the assignment. 
		For example - assignment is "Test", prefix should be 'test'. 
		Will be used in generation of the file
	- 'number' - Non-negative integer with information about number 
		of the assignment. Will be used in generation by pattern
	- 'generation_folder' - String with folder name where generated 
		files will be posted. 
		By default it's 'Generated/' folder, but also can be empty.
	Can be read in that order:
	Specific document 'layout' for every page must contain format of 
		'test' for every possible 'entries'. 
		Every document must contain it's own default 'document_entries', 
		which just appends to every entry.
	This class contain only one method, which generated by default, 
		and won't to be edited. 
		This method calling every time when user asks to generate document.
	Every child class of this must replace only this available parameters 
		to default values for specific kind of documents. 
		Then this class must be appended in all classes list.
	'''

	layout: Documents.DocumentLayout
	test: Tests.Test
	entries: Entries.Entries
	document_entries: Entries.DocumentEntries = Entries.DocumentEntries()
	prefix: str = "prefix"
	number: int = 0
	generation_folder: str = CurrentConfiguration.AssignmentGenerationDirectory


	#@Setters
	def add_prefix_path(self, prefix_path: str):
		'''
		Function to add prefix path for all information about this assignment
		'''
		self.test.add_prefix_path(prefix_path)
		self.layout.add_prefix_path(prefix_path)

	def set_entries(self, entries: Entries.Entries):
		self.entries = entries


	#@Getters
	def __get_output_file_name__(self, 
			appending_string: str, 
			with_prefix: bool = True,
			as_path: bool = False
	) -> str:
		'''Function to get output path of assignment with full name'''

		#Add name
		path = Functions.Path(output_file)

		if with_prefix:
			#If prefix is held, add it to file name
			path.add_file_prefix(f"{self.prefix}{self.number}_")

		#If return as path - return object of path class
		if as_path:
			return path
		else:
			return path.get_full_path()


	#@Readers
	def __read_test_tasks_informations__(self, is_all_tasks: bool = False):
		'''Function to read all tasks informations in test'''

		#Set tests variable of all tasks:
		self.test.set_all_tasks_generation(is_all_tasks)

		#For all tests, read tasks
		for exercise in self.test.get_exercises():
			for tasks_information in exercise.get_tasks_information_list():
				tasks_information.get_tasks().read_information()


	#@Generators
	def __generate_pages_information__(self) -> Documents.PagesInformation:
		'''Function to generate page information with entries'''

		#First of all, generate entries elements
		entries_elements = self.entries.generate_information()

		#When entries are ready, generate information about pages:
		pages_information = Documents.PagesInformation()

		#Then, generate page value for all pages, which in common 
		# will be pages information
		for entry in entries_elements:
			
			#Construct page values from current entry information and all 
			# document entry information, and add them class of Test format
			page_values = Documents.PageValues(
				**entry.dict(), 
				**self.document_entries.dict(), 
				test_option=self.test
			)

			#Append this page value into pages information
			pages_information.append(page_values) 

		return pages_information

	def generate(self, 
			output_file: str = None, 
			with_prefix: bool = True, 
			only_content: bool = False, 
			is_all_tasks: bool = False
	) -> [str, Functions.Path]:
		'''
		Function to generate Assignment document for various 'entries'. 
		Arguments:
		- 'output_file': output file name. Will be generated in special 
			generation folder. If false, return two possibilities, 
			which depends on only_content argument.
		- 'with_prefix': information about generating file with prefix. 
			By default it's true. 
			Append in filename at the beginning information about 
			assignment prefix and assignment number
		- 'only_content':  works only if there is no output_file argument. 
			Returns string of the content of the document, 
			if true, otherwice return all document string 
			(may be posted in file)
		- 'is_all_tasks': Key for creating all available tasks in files 
			(for debug, if True - generate ALL tasks from files, 
			by default it's False - generate tasks as default)
		'''

		#Read all information of tasks in test
		self.__read_test_tasks_informations__(is_all_tasks)

		#Generate information about pages with available entries
		pages_information = self.__generate_pages_information__()

		#Then generate Document object with containing pages information 
		document = Documents.Document(self.layout, pages_information)
			
		#If there is no output file, return just string
		if not output_file:
			if only_content:
				return document.generate_content()
			else:
				return document.generate_document_string()
		else:
			#Otherwise generate document on path

			#Generate path for output file (as path)
			path = self.__get_output_file_name__(output_file, with_prefix, True)

			#Add generation folder to path
			path.add_path(self.generation_folder)

			#Then generate document with this path
			document.generate_document(path.get_full_path())
			return path


class AssignmentsList(Functions.StructList):
	'''
	AssignmentsList - class which can generate more than one assignment 
		in one document. Contains list of Assignments. 
	Assume that this assignments has same document page style and same layout
	Initial arguments:
	- 'assignmentslist' - list of objects of class 'Assignment'
	Available parameters:
	- 'structlist' - list of objects of class 'Assignment'
	- 'prefixes' - dictionary of sorted prefixes with assignments. 
		Sorting will be only for equal parameters 'layout' and 'prefix' 
		of the class
	Assignments with prefix "__other__" will be generated 
		in individual documents ordering
	Assume that generate function will be called only once
	'''

	def __init__(self, assignments_list: list[Assignment] = None):
		super().__init__(assignments_list)
		self.dict_assignments = {"__other__": []}


	#@Setters
	def append(self, assignment: Assignment):
		super().append(assignment)
	
	def add_prefix_path(self, prefix_path: str):
		'''Function to add prefix path for all assignments in this list'''
		for assignment in self.structlist:
			assignment.add_prefix_path(prefix_path)

	def order_by_layout(self):
		'''
		Function to ordering assignments in their prefix-layout formats.
		Returns dictionary in format - keys are prefix name, values are 
			lists of assignments, sorted in struclist order.
		'''

		#For all assignments
		for assignment in self.structlist:

			#Get prefix to append, and then append
			prefix = self.get_prefix_to_append(assignment)
			self.dict_assignments[prefix].append(assignment)


	#@Getters
	def get_prefix_to_append(self, assignment: Assignment) -> str:
		'''Function to get in which prefix will append this assignment'''

		if list_assignments := self.dict_assignments.get(assignment.prefix):
			#If assignment prefix exists inside dictionary

			if list_assignments[0].layout.layout == assignment.layout.layout:
				#And if layouts of this assignment and presented 
				# in list are equal:
				return assignment.prefix
			else:
				#If layouts are different, move it to other category
				return "__other__"
		else:
			#Otherwise, create list by this prefix, and return this prefix
			self.dict_assignments[assignment.prefix] = []
			return assignment.prefix

	def get_filepath_from(self, 
			output_file: str,
			with_prefix: bool, 
			prefix: str,
			numbers: str, 
			as_path: bool = False
	):
		'''Function to generate filepath for assignment if with prefix'''
		path = Functions.Path(output_file)

		if with_prefix:
			#If prefix is held, add it to file name
			path.add_file_prefix(f"{prefix}{numbers}_")

		if as_path:
			return path
		else:
			return path.get_full_path()


	#@Generators
	def generate_by_prefix(self, 
			prefix: str, 
			output_file: str = None, 
			with_prefix: bool = True, 
			is_all_tasks: bool = False
	) -> [str, Functions.Path, None]:
		'''
		Function to generate all available assignments from list. 
		Returns document string or file's path. Returns none in case of
		prefix "__other__"
		'''

		#If this is "other" prefix, return nothing, 
		# because it has another generator
		if prefix == "__other__":
			return

		#If ths prefix exists
		if assignments := self.dict_assignments.get(prefix):
			
			numbers = "".join([
				str(assignment.number) 
				for assignment in assignments
			])

			layout = assignments[0].layout
			generation_folder = assignments[0].generation_folder

			#Generate only content
			content = "\n".join([
				assignment.generate(
					only_content=True, 
					is_all_tasks=is_all_tasks) 
				for assignment in assignments
			])

			#Then get document string 
			document_string = layout.get_document_string_wth_content(content)

			#If there is no output file
			if not output_file:
				#Return just document string
				return document_string

			else:
				#Otherwise generate document on path

				#Generate path
				path = self.get_filepath_from(
					output_file, with_prefix, prefix, numbers, True
				)

				#Add generation folder to path
				path.add_path(generation_folder)

				#Then generate document with this path
				with open(path.get_full_path(), "w") as file:
					file.write(document_string)

				return path

	def generate_as_single(self, 
			prefix_name: str = "__other__", 
			output_file: str = None, 
			with_prefix: bool = True, 
			is_all_tasks: bool = False
	) -> [list[str]]:
		'''
		Function to generate signle assignments from prefix name
		By default prefix is for others (which isn't sorted)
		'''
		documents = []
		for assignment in self.dict_assignments.get(prefix_name):
			#For all assignments in this prefix name, 
			# generate individual assignment document
			document = assignment.generate(
				output_file, 
				with_prefix, 
				is_all_tasks=is_all_tasks
			)
			documents.append(document)

		if not output_file:
			return documents
		else:
			return []


	def generate(self, 
			output_file: str = None, 
			with_prefix: bool = True, 
			separated: bool = False, 
			is_all_tasks: bool = False
	) -> [list[str, Functions.Path], None]:
		'''
		Function to generate all possible files
		Arguments:
		- 'output_file': string of the output file
		- 'with_prefix': generate file with prefix in name (by default - True)
		- 'separated': generate files with similar assignment types separately
			(by default - False: means merge all similar in one file)
		- 'is_all_tasks': Key for creating all available tasks in files 
			(for debug, if True - generate ALL tasks from files, 
			by default it's False - generate tasks as default)
		'''

		#First of all - sort all files to layouts
		self.order_by_layout()

		documents = []
		#For all prefix in assignments
		for prefix in self.dict_assignments.keys():

			#If prefix is not in others, and files without separating 
			if prefix != "__other__" and not separated:
				#Generate document by prefix
				document = self.generate_by_prefix(
					prefix, 
					output_file, 
					with_prefix, 
					is_all_tasks
				)
				documents.append(document)
			
			#Otherwise generate others (or, if separated, 
			# generate them separately)
			else:
				#Then just add list of documents into documents list
				documents_ = self.generate_as_single(
					prefix, 
					output_file, 
					with_prefix, 
					is_all_tasks
				)
				documents += documents_

		# if not output_file:
		return documents


class AssignmentsInformationClass:
	'''
	AssignmentsInformationClass - class which contains information 
		about generated labs.
	'''

	def __init__(self):
		self.dict = {}
		self.descriptions = {}

	#@Setters
	def append(self, assignment_class: Assignment, key: str):
		'''Function to append assignment class into this module'''
		if self.dict.get(key) == None:
			self.dict[key] = {}
			self.descriptions[key] = "No description"

		#Append assignment with it's number inside class
		self.dict[key][assignment_class.number] = assignment_class

	def set_description(self, key: str, description: str):
		'''Function to set description to special key'''
		self.descriptions[key] = description


	#@Getters
	def get(self, key: str, number: int) -> (Assignment, None):
		'''Function to get assignment with it's key and number'''
		if self.is_available(key, number):
			return self.dict[key][number]

	def get_description(self, key: str) -> str:
		'''Function to get description of special key'''
		if self.descriptions.get(key):
			return self.descriptions[key]

	def is_available(self, key: str, number: int) -> bool:
		return bool(self.dict.get(key) and self.dict[key].get(number))

	def get_dict_assignments(self) -> dict[str, list[int]]:
		'''Function to get list of assignments keys and indicies'''
		return {
			key: list(self.dict[key].keys())
			for key in self.dict.keys()
		}
