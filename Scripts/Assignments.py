from .Generators import Tests
from .Generators import Entries
from .Generators import Documents

from . import Functions

class Assignment:
	'''
	Assignment - parent class to work with assignments, containing all information about them. 
	Must contain default values for next parameters:
	- 'layout' - 'DocumentLayout' with information about document path and replacement string, and it's PageStyle
	- 'test' - 'Test' with it's 'Excercises', 
	- 'entries' - 'Entries' with their 'generate_information' method. This value can't be default, because it's generating by user's asking. For this situation exist method 'set_entries'
	- 'document_entry' - 'Struct' with additional information, which presented in pagestyle excercises format string. This argument may not be presented in class, by default it's empty entry
	- 'prefix' - String with prefix of the assignment. Must contain only latin symbols, and represent logic of the assignment. For example - assignment is "Test", prefix should be 'test'. Will be used in generation of the file
	- 'number' - Non-negative integer with information about number of the assignment. Will be used in generation by pattern
	- 'generation_folder' - String with folder name where generated files will be posted. By default it's 'Generated/' folder, but can be empty.
	Can be read in that order:
	Specific document 'layout' for every page must contain format of 'test' for every possible 'entries'. Every document must contain it's own default 'document_entries', which just appends to every entry.
	This class contain only one method, which generated by default, and won't to be edited. This method called every time when user asks to generate document.
	Every child class of this must replace only this available parameters to default values for specific kind of documents. Then this class must be appended in all classes list.
	'''

	layout: Documents.DocumentLayout
	test: Tests.Test
	entries: Entries.Entries
	document_entry: Functions.Struct = Functions.Struct()
	prefix: str = "prefix"
	number: int = 0
	generation_folder: str = "Generated/"

	def set_entries(self, entries: Entries.Entries):
		self.entries = entries

	def generate(self, output_file: str = None, with_prefix: bool = True, only_content: bool = False) -> [str, None]:
		'''
		Function to generate Assignment document for various 'entries'. 
		Arguments:
		- 'output_file': output file name. Will be generated in special generation folder. If false, return two possibilities, which depends on only_content argument.
		- 'with_prefix': information about generating file with prefix. By default it's true. Append in filename at the beginning information about assignment prefix and assignment number
		- 'only_content':  works only if there is no output_file argument. Returns string of the content of the document, if true, otherwice return all document string (may be posted in file)
		'''

		#First of all, generate entries elements
		entries_elements = self.entries.generate_information()

		#For all tests, read tasks
		for excercise in self.test.get_excercises():
			for tasks_information in excercise.get_tasks_information_list():
				tasks_information.get_tasks().read_information()

		#When entries are ready, generate information about pages:
		pages_information = Documents.PagesInformation()

		#Then, generate page value for all pages, which in common will be pages information
		for entry in entries_elements:
			#Construct page values from current entry information and all document entry information, and add them class of Test format
			page_values = Documents.PageValues(
				**entry.dict(), 
				**self.document_entry.dict(), 
				test_option=self.test
			)
			#Append this page value into pages information
			pages_information.append(page_values) 

		#Then generate Document object with containing pages information
		document = Documents.Document(self.layout, pages_information)
			
		#If there is no output file, return just string
		if not output_file:
			if only_content:
				return document.generate_content()
			else:
				return document.generate_document_string()
		else:
			#Otherwise generate document on path

			#First of all - add generation folder to path
			path = Functions.Path(output_file)
			path.add_path(self.generation_folder)

			if with_prefix:
				#If prefix is held, add it to file name
				path.add_file_prefix(f"{self.prefix}{self.number}_")

			#Then generate document with this path
			document.generate_document(path.get_full_path())

	def add_prefix_path(self, prefix_path: str):
		'''Function to add prefix path for all information about this assignment'''
		self.test.add_prefix_path(prefix_path)
		self.layout.add_prefix_path(prefix_path)

class AssignmentsList(Functions.StructList):
	'''
	AssignmentsList - class which can generate more than one assignment in one document. Contains list of Assignments. 
	Assume that this assignments has same document page style and same layout
	Initial arguments:
	- 'assignmentslist' - list of objects of class 'Assignment'
	Available parameters:
	- 'structlist' - list of objects of class 'Assignment'
	- 'prefixes' - dictionary of sorted prefixes with assignments. Sorting will be only for equal parameters 'layout' and 'prefix' of the class
	Assignments with prefix "__other__" will be generated in individual documents ordering
	Assume that generate function will be called only once
	'''

	def __init__(self, assignmentslist: list[Assignment] = None):
		super().__init__(assignmentslist)
		self.dict_assignments = {"__other__": []}

	def append(self, assignment: Assignment):
		super().append(assignment)

	def get_prefix_to_append(self, assignment: Assignment) -> str:
		'''Function to get in which prefix will append this assignment'''

		if list_assignments := self.dict_assignments.get(assignment.prefix):
			#If assignment prefix exists inside dictionary

			if list_assignments[0].layout.layout == assignment.layout.layout:
				#And if layouts of this assignment and presented in list are equal:
				return assignment.prefix
			else:
				#If layouts are different, move it to other category
				return "__other__"
		else:
			#Otherwise, create list by this prefix, and return this prefix
			self.dict_assignments[assignment.prefix] = []
			return assignment.prefix

	def order_by_layout(self):
		'''
		Function to ordering assignments in their prefix-layout formats.
		Returns dictionary in format - keys are prefix name, values are lists of assignments, sorted in struclist order.
		'''

		#For all assignments
		for assignment in self.structlist:

			#Get prefix to append, and then append
			prefix = self.get_prefix_to_append(assignment)
			self.dict_assignments[prefix].append(assignment)

	def generate_by_prefix(self, prefix: str, output_file: str = None, with_prefix: bool = True) -> [str, None]:
		'''Function to generate all available assignments from list'''

		#If this is "other" prefix, return nothing, because it has another generator
		if prefix == "__other__":
			return

		#If ths prefix exists
		if assignments := self.dict_assignments.get(prefix):
			
			numbers = "".join([str(assignment.number) for assignment in assignments])
			layout = assignments[0].layout
			generation_folder = assignments[0].generation_folder

			#Generate only content
			content = "\n".join([assignment.generate(only_content=True) for assignment in assignments])

			#Then get document string 
			document_string = layout.get_document_string_wth_content(content)

			#If there is no output file
			if not output_file:
				#Return just document string
				return document_string

			else:
				#Otherwise generate document on path

				#First of all - add generation folder to path
				path = Functions.Path(output_file)
				path.add_path(generation_folder)

				if with_prefix:
					#If prefix is held, add it to file name
					path.add_file_prefix(f"{prefix}{numbers}_")

				#Then generate document with this path
				with open(path.get_full_path(), "w") as file:
					file.write(document_string)

	def generate_as_single(self, output_file: str = None, with_prefix: bool = True, prefix_name: str = "__other__") -> [list[str]]:
		'''Function to generate signle assignments from prefix name'''

		documents = []
		for assignment in self.dict_assignments.get(prefix_name):
			#For all assignments in this prefix name, generate individual assignment document
			document = assignment.generate(output_file, with_prefix)
			documents.append(document)

		if not output_file:
			return documents
		else:
			return []

	def generate(self, output_file: str = None, with_prefix: bool = True, separated: bool = False) -> [list[str], None]:
		'''
		Function to generate all possible files
		Arguments:
		- 'output_file': string of the output file
		- 'with_prefix': generate file with prefix in name (by default - True)
		- 'separated': generate files with similar assignment types separately (by default - False: means merge all similar in one file)
		'''

		#First of all - sort all files to layouts
		self.order_by_layout()

		documents = []
		#For all prefix in assignments
		for prefix in self.dict_assignments.keys():
			if prefix != "__other__" and not separated:
				#If prefix is not in others, and files without separating - generate document by prefix
				document = self.generate_by_prefix(prefix, output_file, with_prefix)
				documents.append(document)
			else:
				#Otherwise generate others (or, if separated, generate them separately), and just add list of documents into documents list
				documents_ = self.generate_as_single(output_file, with_prefix, prefix)
				documents += documents_

		if not output_file:
			return documents

	def add_prefix_path(self, prefix_path: str):
		'''Function to add prefix path for all assignments in this list'''
		for assignment in self.structlist:
			assignment.add_prefix_path(prefix_path)

class AssignmentsInformationClass:
	'''
	AssignmentsInformationClass - class which contains information about generated labs.
	'''

	def __init__(self):
		self.dict = {}

	def append(self, assignment_class, key: str):
		'''Function to append assignment class into this module'''
		if self.dict.get(key) == None:
			self.dict[key] = {}

		#Append assignment with it's number inside class
		self.dict[key][assignment_class.number] = assignment_class

	def get(self, key: str, number: int):
		'''Function to get assignment with it's key and number'''
		if self.dict.get(key):
			return self.dict[key].get(number)