from Scripts import Functions
from Scripts import Globals

from Scripts.Generators import Tests
from Scripts.Generators import Entries
from Scripts.Generators import Documents

from Scripts.Logging import Logging

CurrentConfiguration = Globals.CurrentConfiguration.get_configuration()

class Assignment:
	'''
	Assignment - parent class to work with assignments, containing 
		all information about them. 
	Must contain default values for next parameters:
	- 'layout' - 'DocumentLayout' with information about 
		document path and replacement string, and it's PageStyle
	- 'test' - 'Test' with it's 'Exercises', 
	- 'entries' - 'Entries' with their 'generate_information' method. 
		This value can't be default, because it's generating by user's asking.
		For this situation exist method 'set_entries'
	- 'document_entries' - 'DocumentEntries' with additional information, 
		which presented in pagestyle exercises format string. 
		This argument may not be presented in class, 
		by default it's empty entry
	- 'prefix' - String with prefix of the assignment. 
		Must contain only latin symbols, and represent logic 
		of the assignment. 
		For example - assignment is "Test", prefix should be 'test'. 
		Will be used in generation of the file
	- 'number' - Non-negative integer with information about number 
		of the assignment. Will be used in generation by pattern
	- 'generation_folder' - String with folder name where generated 
		files will be posted. 
		By default it's 'Generated/' folder, but also can be empty.
	Can be read in that order:
	Specific document 'layout' for every page must contain format of 
		'test' for every possible 'entries'. 
		Every document must contain it's own default 'document_entries', 
		which just appends to every entry.
	This class contain only one method, which generated by default, 
		and won't to be edited. 
		This method calling every time when user asks to generate document.
	Every child class of this must replace only this available parameters 
		to default values for specific kind of documents. 
		Then this class must be appended in all classes list.
	'''

	layout: Documents.DocumentLayout
	test: Tests.Test
	entries: Entries.Entries
	document_entries: Entries.DocumentEntries = Entries.DocumentEntries()
	prefix: str = "prefix"
	number: int = 0
	generation_folder: str = CurrentConfiguration.AssignmentGenerationDirectory


	#@Setters
	def add_prefix_path(self, prefix_path: str):
		'''
		Function to add prefix path for all information about this assignment
		'''
		self.test.add_prefix_path(prefix_path)
		self.layout.add_prefix_path(prefix_path)

	def set_entries(self, entries: Entries.Entries):
		self.entries = entries


	#@Getters
	def __get_output_file_name__(self, 
			output_file: str, 
			with_prefix: bool = True,
			as_path: bool = False
	) -> str:
		'''Function to get output path of assignment with full name'''

		#Add name
		path = Functions.Path(output_file)

		if with_prefix:
			#If prefix is held, add it to file name
			path.add_file_prefix(f"{self.prefix}{self.number}_")

		#If return as path - return object of path class
		if as_path:
			return path
		else:
			return path.get_full_path()


	#@Readers
	def __read_test_tasks_informations__(self, is_all_tasks: bool = False):
		'''Function to read all tasks informations in test'''

		#Set tests variable of all tasks:
		self.test.set_all_tasks_generation(is_all_tasks)

		#For all tests, read tasks
		for exercise in self.test.get_exercises():
			for tasks_information in exercise.get_tasks_information_list():
				tasks_information.get_tasks().read_information()


	#@Generators
	def __generate_pages_information__(self) -> Documents.PagesInformation:
		'''Function to generate page information with entries'''

		#First of all, generate entries elements
		entries_elements = self.entries.generate_information()

		#When entries are ready, generate information about pages:
		pages_information = Documents.PagesInformation()

		#Then, generate page value for all pages, which in common 
		# will be pages information
		for entry in entries_elements:
			
			#Construct page values from current entry information and all 
			# document entry information, and add them class of Test format
			page_values = Documents.PageValues(
				**entry.dict(), 
				**self.document_entries.dict(), 
				test_option=self.test
			)

			#Append this page value into pages information
			pages_information.append(page_values) 

		return pages_information

	def generate(self, 
			output_file: str = None, 
			with_prefix: bool = True, 
			only_content: bool = False, 
			is_all_tasks: bool = False
	) -> [str, Functions.Path]:
		'''
		Function to generate Assignment document for various 'entries'. 
		Arguments:
		- 'output_file': output file name. Will be generated in special 
			generation folder. If false, return two possibilities, 
			which depends on only_content argument.
		- 'with_prefix': information about generating file with prefix. 
			By default it's true. 
			Append in filename at the beginning information about 
			assignment prefix and assignment number
		- 'only_content':  works only if there is no output_file argument. 
			Returns string of the content of the document, 
			if true, otherwice return all document string 
			(may be posted in file)
		- 'is_all_tasks': Key for creating all available tasks in files 
			(for debug, if True - generate ALL tasks from files, 
			by default it's False - generate tasks as default)
		'''

		#Read all information of tasks in test
		self.__read_test_tasks_informations__(is_all_tasks)

		#Generate information about pages with available entries
		pages_information = self.__generate_pages_information__()

		#Then generate Document object with containing pages information 
		document = Documents.Document(self.layout, pages_information)
			
		#If there is no output file, return just string
		if not output_file:
			if only_content:
				return document.generate_content()
			else:
				return document.generate_document_string()
		else:
			#Otherwise generate document on path

			#Generate path for output file (as path)
			path = self.__get_output_file_name__(output_file, with_prefix, True)

			#Add generation folder to path
			path.add_path(self.generation_folder)

			#Then generate document with this path
			document.generate_document(path.get_full_path())
			return path


class AssignmentsList(Functions.StructList):
	'''
	AssignmentsList - class which can generate more than one assignment 
		in one document. Contains list of Assignments. 
	Assume that this assignments has same document page style and same layout
	Initial arguments:
	- 'assignments_list' - list of objects of class 'Assignment'
	Available parameters:
	- 'structlist' - list of objects of class 'Assignment'
	- 'dict_assignments' - dictionary of sorted prefixes with assignments,
		sorted by layouts.

	Assume that generate function will be called only once
	'''

	def __init__(self, assignments_list: list[Assignment] = None):
		super().__init__(assignments_list)
		self.dict_assignments = {}


	#@Setters
	def append(self, assignment: Assignment):
		super().append(assignment)
	
	def add_prefix_path(self, prefix_path: str):
		'''Function to add prefix path for all assignments in this list'''
		for assignment in self.structlist:
			assignment.add_prefix_path(prefix_path)

	def order_by_layout(self):
		'''
		Function to ordering assignments in their prefix-layout formats.
		Returns dictionary in format - keys are prefix name, values are 
			lists of assignments, sorted in struclist order.
		'''

		#For all assignments
		for assignment in self.structlist:

			#Get prefix and layout to append, and then append assignment by them
			prefix, layout = self.get_prefix_layout_to_append(assignment)
			self.dict_assignments[prefix][layout].append(assignment)


	#@Getters
	def get_prefix_layout_to_append(self, assignment: Assignment) -> str:
		'''
		Function to get in which prefix and which layout this assignment 
		will appear
		'''

		#Get prefix and layout
		prefix = assignment.prefix
		assignment_layout = assignment.layout.layout
		
		#Get layout dictionary from assignments dictionary with specific prefix
		dict_layouts = self.dict_assignments.get(prefix)
		
		if dict_layouts:
			#If layouts for this prefix exists inside dictionary
			# get list of assignments
			list_assignments = dict_layouts.get(assignment_layout)
			
			if not list_assignments:
				#If there is no list of assignments for this assignment layout,
				# create it
				self.dict_assignments[prefix][assignment_layout] = list()

			#Return prefix and layout
			return prefix, assignment_layout

		else:
			#Otherwise, create dictionary with current assignment layout inside
			# with empty list of assignments
			self.dict_assignments[prefix] = {assignment_layout: list()}
			return prefix, assignment_layout


	def get_filepath_from(self, 
			output_file: str,
			with_prefix: bool, 
			prefix: str,
			numbers: str, 
			as_path: bool = False
	):
		'''Function to generate filepath for assignment if with prefix'''
		path = Functions.Path(output_file)

		if with_prefix:
			#If prefix is held, add it to file name
			path.add_file_prefix(f"{prefix}{numbers}_")

		if as_path:
			return path
		else:
			return path.get_full_path()


	#@Generators
	def generate_by_prefix_layout(self, 
			prefix: str, 
			layout: str,
			output_file: str = None, 
			with_prefix: bool = True, 
			is_all_tasks: bool = False,
			is_exec_command: bool = False
	) -> [str, Functions.Path, None]:
		'''
		Function to generate all available assignments from list. 
		Returns document string or file's path, or None, if dictionary is empty
		'''

		#Get dictionary with layouts and assignments inside by prefix
		layouts = self.dict_assignments.get(prefix)

		#If this prefix exists
		if layouts:

			#Get list of assignments for chosen layout
			assignments = layouts.get(layout)

			#If list of assignments exists
			if assignments:

				#Get numbers of assignments
				numbers = "".join([
					str(assignment.number) 
					for assignment in assignments
				])

				#Find generation folder
				layout_obj = assignments[0].layout
				generation_folder = assignments[0].generation_folder

				#Generate only content
				content = "\n".join([
					assignment.generate(
						only_content=True, 
						is_all_tasks=is_all_tasks) 
					for assignment in assignments
				])

				#Then get document string 
				document_out = layout_obj.get_document_string_wth_content(content)

				#If there is no output file
				if not output_file:
					#Return just document string
					return document_out

				else:
					#Otherwise generate document on path

					#Generate path
					path = self.get_filepath_from(
						output_file, with_prefix, prefix, numbers, True
					)

					#Add generation folder to path
					path.add_path(generation_folder)

					#Then generate document with this path
					with open(path.get_full_path(), "w") as file:
						file.write(document_out)
						Logging.log("\t" + path.get_full_path())

					#If needs to execute command
					if is_exec_command:
						#Exec it
						execs = CurrentConfiguration.OSExec
						execs = Functions.Functions.replace_path_substrings(execs, path)
						
						Logging.warning("Executing:", execs)
						Functions.Exec.osexec(execs)

					#Return saved path of document
					return path


	def generate_as_single(self, 
			prefix_name: str = "", 
			output_file: str = None, 
			with_prefix: bool = True, 
			is_all_tasks: bool = False,
			is_exec_command: bool = False
	) -> [list[str]]:
		'''
		Function to generate signle assignments from prefix name.
		'''

		documents = []

		#If prefix exists in dictionary
		if prefix_name in self.dict_assignments.keys():

			#For all layouts
			for layout in self.dict_assignments.get(prefix_name).keys():

				#Get assignments
				assignments = self.dict_assignments.get(prefix_name).get(layout)
				for assignment in assignments:
					#For all assignments in this prefix name with specific 
					# layout, generate individual assignment document
					document = assignment.generate(
						output_file, 
						with_prefix, 
						is_all_tasks=is_all_tasks,
						is_exec_command=is_exec_command
					)
					documents.append(document)
		
		return documents


	def generate(self, 
			output_file: str = None, 
			with_prefix: bool = True, 
			separated: bool = False, 
			is_all_tasks: bool = False,
			is_exec_command: bool = False
	) -> [list[str, Functions.Path], None]:
		'''
		Function to generate all possible files
		Arguments:
		- 'output_file': string of the output file
		- 'with_prefix': generate file with prefix in name (by default - True)
		- 'separated': generate files with similar assignment types separately
			(by default - False: means merge all similar in one file)
		- 'is_all_tasks': Key for creating all available tasks in files 
			(for debug, if True - generate ALL tasks from files, 
			by default it's False - generate tasks as default)
		'''

		#First of all - sort all files to layouts
		self.order_by_layout()

		documents = []
		#For all prefix in assignments
		for prefix in self.dict_assignments.keys():

			#If files not separated
			if not separated:
				
				#Get all layouts for this prefix
				layouts = self.dict_assignments.get(prefix)

				#For all layouts
				for layout in layouts.keys():

					#Generate document by prefix and layout
					document = self.generate_by_prefix_layout(
						prefix, 
						layout,
						output_file, 
						with_prefix, 
						is_all_tasks,
						is_exec_command
					)
					documents.append(document)
			
			#Otherwise generate separated documents
			else:

				documents_ = self.generate_as_single(
					prefix, 
					output_file, 
					with_prefix, 
					is_all_tasks,
					is_exec_command
				)

				#Then just add list of documents into documents list
				documents += documents_

		return documents


class AssignmentsInformationClass:
	'''
	AssignmentsInformationClass - class which contains information 
		about generated labs.
	'''

	def __init__(self):
		self.dict = {}
		self.descriptions = {}

	#@Setters
	def append(self, assignment_class: Assignment, key: str):
		'''Function to append assignment class into this module'''
		if self.dict.get(key) == None:
			self.dict[key] = {}
			self.descriptions[key] = "No description"

		#Append assignment with it's number inside class
		self.dict[key][assignment_class.number] = assignment_class

	def set_description(self, key: str, description: str):
		'''Function to set description to special key'''
		self.descriptions[key] = description


	#@Getters
	def get(self, key: str, number: int) -> (Assignment, None):
		'''Function to get assignment with it's key and number'''
		if self.is_available(key, number):
			return self.dict[key][number]

	def get_description(self, key: str) -> str:
		'''Function to get description of special key'''
		if self.descriptions.get(key):
			return self.descriptions[key]

	def is_available(self, key: str, number: int) -> bool:
		return bool(self.dict.get(key) and self.dict[key].get(number))

	def get_dict_assignments(self) -> dict[str, list[int]]:
		'''Function to get list of assignments keys and indicies'''
		return {
			key: list(self.dict[key].keys())
			for key in self.dict.keys()
		}
